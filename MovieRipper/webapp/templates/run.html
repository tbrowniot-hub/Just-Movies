{% extends "_layout.html" %}
{% block title %}Run Â· MovieRipper{% endblock %}
{% block content %}
<section class="card">
  <h2>Run Queue</h2>
  <form id="start-form" class="form-grid">
    <label>Queue path
      <input id="queue-path" name="queue_path" value="MovieRipper/movie_queue.json" />
    </label>
    <label>Config path
      <input id="config-path" name="config_path" value="config.json" />
    </label>

    <div class="card">
      <p><strong>Staging root:</strong> <code id="staging-root">(not loaded)</code> <button id="copy-staging" type="button" class="secondary">Copy path</button></p>
      <p><strong>Final root:</strong> <code id="final-root">(not loaded)</code> <button id="copy-final" type="button" class="secondary">Copy path</button></p>
      <p id="job-preview" class="muted">Job folder preview: (unavailable)</p>
      <p id="run-warnings" class="muted"></p>
    </div>

    <div id="run-error" class="error hidden"></div>
    <div class="row gap">
      <button id="start-btn" type="submit">Start</button>
      <button id="stop-btn" type="button" class="danger">Stop</button>
    </div>
  </form>

  <p id="big-status" class="badge idle">Idle</p>
  <p id="run-meta" class="muted">No active run.</p>
</section>

<section class="card">
  <div class="row gap">
    <h3>Logs</h3>
    <label><input id="pause-scroll" type="checkbox" /> Pause autoscroll</label>
  </div>
  <pre id="logs-box" class="logs"></pre>
</section>
{% endblock %}
{% block scripts %}
<script>
const startForm = document.getElementById('start-form');
const startBtn = document.getElementById('start-btn');
const stopBtn = document.getElementById('stop-btn');
const bigStatus = document.getElementById('big-status');
const runMeta = document.getElementById('run-meta');
const logsBox = document.getElementById('logs-box');
const pauseScroll = document.getElementById('pause-scroll');
const queuePathInput = document.getElementById('queue-path');
const configPathInput = document.getElementById('config-path');
const runError = document.getElementById('run-error');
const runWarnings = document.getElementById('run-warnings');
const stagingRoot = document.getElementById('staging-root');
const finalRoot = document.getElementById('final-root');
const jobPreview = document.getElementById('job-preview');
const copyStaging = document.getElementById('copy-staging');
const copyFinal = document.getElementById('copy-final');

const LS_QUEUE_PATH = 'movieripper.run.queue_path';
const LS_CONFIG_PATH = 'movieripper.run.config_path';
const LS_INDEX_PATH = 'movieripper.queue.index_path';
const DEFAULT_INDEX_PATH = 'MovieRipper/movie_index.json';

let latestPathPayload = null;

function readStoredValue(key, fallback) {
  const value = localStorage.getItem(key);
  return value && value.trim() ? value : fallback;
}

function setError(message) {
  if (message) {
    runError.textContent = message;
    runError.classList.remove('hidden');
  } else {
    runError.textContent = '';
    runError.classList.add('hidden');
  }
}

function applyConfigDetails(payload) {
  latestPathPayload = payload;
  stagingRoot.textContent = payload?.staging_root || '(missing)';
  finalRoot.textContent = payload?.final_root || '(missing)';
  jobPreview.textContent = `Job folder preview: ${payload?.job_folder_preview || '(unavailable)'}`;
  const warnings = payload?.config_warnings || [];
  runWarnings.textContent = warnings.length ? `Warnings: ${warnings.join(' | ')}` : '';
}

async function validatePaths() {
  const res = await fetch('/api/v1/run/paths', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      queue_path: queuePathInput.value,
      config_path: configPathInput.value,
      index_path: readStoredValue(LS_INDEX_PATH, DEFAULT_INDEX_PATH),
    }),
  });
  if (!res.ok) {
    setError('Unable to verify file paths right now.');
    return false;
  }

  const payload = await res.json();
  applyConfigDetails(payload);

  if (!payload.config_exists) {
    setError(`Config file not found at ${payload.config_path}. Create config.json from config.example.json, then try again.`);
    return false;
  }
  if (!payload.config_valid) {
    setError((payload.config_errors || ['Config is invalid']).join(' '));
    return false;
  }
  if (!payload.queue_exists) {
    setError(`Queue file not found at ${payload.queue_path}. Build and save a queue from the Queue page first.`);
    return false;
  }

  setError('');
  return true;
}

async function copyText(text) {
  if (!text || text === '(missing)') return;
  try {
    await navigator.clipboard.writeText(text);
  } catch (err) {
    setError(`Clipboard copy failed: ${err}`);
  }
}

copyStaging.addEventListener('click', () => copyText(stagingRoot.textContent));
copyFinal.addEventListener('click', () => copyText(finalRoot.textContent));

queuePathInput.value = readStoredValue(LS_QUEUE_PATH, queuePathInput.value);
configPathInput.value = readStoredValue(LS_CONFIG_PATH, configPathInput.value);
queuePathInput.addEventListener('input', async () => {
  localStorage.setItem(LS_QUEUE_PATH, queuePathInput.value);
  await validatePaths();
});
configPathInput.addEventListener('input', async () => {
  localStorage.setItem(LS_CONFIG_PATH, configPathInput.value);
  await validatePaths();
});

startForm.onsubmit = async (e) => {
  e.preventDefault();
  localStorage.setItem(LS_QUEUE_PATH, queuePathInput.value);
  localStorage.setItem(LS_CONFIG_PATH, configPathInput.value);

  const canStart = await validatePaths();
  if (!canStart) {
    return;
  }

  const fd = new FormData(startForm);
  const res = await fetch('/api/v1/run/start', {method: 'POST', body: fd});
  if (!res.ok) {
    const payload = await res.json();
    setError(payload.detail || 'Unable to start');
    runMeta.textContent = payload.detail || 'Unable to start';
  }
};

stopBtn.onclick = async () => {
  await fetch('/api/v1/run/stop', {method: 'POST'});
};

function updateButtons(status) {
  const running = !!status.running;
  startBtn.disabled = running || !latestPathPayload?.config_exists || !latestPathPayload?.config_valid;
  stopBtn.disabled = !running;
}

setInterval(async () => {
  const status = await (await fetch('/api/v1/status')).json();
  const logs = await (await fetch('/api/v1/logs?tail=200')).json();

  const step = status.step || 'idle';
  const running = !!status.running;
  bigStatus.textContent = running ? `Running: ${step}` : `Idle: ${step}`;
  bigStatus.className = `badge ${running ? 'running' : 'idle'}`;

  const current = status.current || '-';
  const total = status.total || '-';
  const title = status.title || '-';
  const clz = status.clz_index || '-';
  const imdb = status.imdb_id || '-';
  runMeta.textContent = `Queue: ${queuePathInput.value} | Config: ${configPathInput.value} | Item ${current}/${total} | ${title} | CLZ ${clz} | IMDb ${imdb}`;

  logsBox.textContent = (logs.lines || []).join('\n');
  if (!pauseScroll.checked) {
    logsBox.scrollTop = logsBox.scrollHeight;
  }

  updateButtons(status);
}, 1000);

validatePaths();
</script>
{% endblock %}
